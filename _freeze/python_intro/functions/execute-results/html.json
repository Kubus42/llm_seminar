{
  "hash": "ed542c5b1237f20e825cf27370203989",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Functions\"\nformat:\n  html:\n    code-fold: false\njupyter: python3\n---\n\n\n\n\n\nFunctions are one of the most important building blocks in Python. \nThey allow you to organize your code into reusable chunks. \nA **function** is a block of code that performs a specific task, and you can \"call\" the function whenever you need that task to be done. \nUsing functions helps make your code more modular, readable, and easier to maintain. \nAs we start dealing with more complex tasks, especially in NLP, functions will help simplify and structure your code.\n\n\n### Defining Functions\n\nYou can define a function using the `def` keyword, followed by the function name, parentheses `()`, and a colon `:`. Inside the function, you write the code that you want the function to execute. Optionally, you can pass **arguments** to the function to customize its behavior, and the function can **return** a value after completing its task.\n\n#### **Basic Syntax:**\n\n::: {#9f1eec24 .cell execution_count=1}\n``` {.python .cell-code}\ndef function_name():\n    # Code to be executed\n    pass\n```\n:::\n\n\n### Example: A Simple Function\n\nLet’s start with a basic example of a function that prints a greeting message.\n\n#### Example:\n\n::: {#00ba4898 .cell execution_count=2}\n``` {.python .cell-code}\ndef greet():\n    print(\"Hello, welcome to Python!\")\n\n# Calling the function\ngreet()  # Output: Hello, welcome to Python!\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nHello, welcome to Python!\n```\n:::\n:::\n\n\nHere, we define a function called `greet()` that prints a message. Every time we call the `greet()` function, the message is printed.\n\n\n\n### Functions with Arguments\n\nFunctions become more powerful when you can pass data to them via **arguments** (also called **parameters**). You can pass one or more arguments into a function, and the function can use those arguments to perform different actions.\n\n#### Example:\n\n::: {#028eef2d .cell execution_count=3}\n``` {.python .cell-code}\ndef greet(name):\n    print(f\"Hello, {name}!\")\n\n# Calling the function with an argument\ngreet(\"Alice\")  # Output: Hello, Alice!\ngreet(\"Bob\")  # Output: Hello, Bob!\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nHello, Alice!\nHello, Bob!\n```\n:::\n:::\n\n\nIn this example, the `greet(name)` function takes one argument, `name`, and includes it in the greeting message. When we call the function with `\"Alice\"` and `\"Bob\"`, it customizes the greeting for each person.\n\n\n\n### Functions with Multiple Arguments\n\nYou can define functions with multiple arguments by separating them with commas. The function will expect all the arguments when called.\n\n#### Example:\n\n::: {#d3fb34b7 .cell execution_count=4}\n``` {.python .cell-code}\ndef add_numbers(a, b):\n    result = a + b\n    print(f\"The sum is: {result}\")\n\n# Calling the function with two arguments\nadd_numbers(3, 5)  # Output: The sum is: 8\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nThe sum is: 8\n```\n:::\n:::\n\n\nHere, the `add_numbers(a, b)` function takes two arguments, `a` and `b`, adds them together, and prints the result.\n\n\n\n### Returning Values from Functions\n\nSometimes, you’ll want your function to return a value instead of just printing something. You can do this using the `return` keyword. A function can return a value that you can store in a variable or use in further calculations.\n\n#### Example:\n\n::: {#49184def .cell execution_count=5}\n``` {.python .cell-code}\ndef add_numbers(a, b):\n    return a + b\n\n# Storing the returned value in a variable\nsum_result = add_numbers(10, 20)\nprint(sum_result)  # Output: 30\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n30\n```\n:::\n:::\n\n\nIn this example, the function `add_numbers(a, b)` returns the sum of `a` and `b`, and we store the result in the `sum_result` variable.\n\n\n\n### Default Arguments\n\nYou can assign **default values** to arguments in your function. If the caller doesn't provide a value for that argument, the default value will be used. This makes your functions more flexible.\n\n#### Example:\n\n::: {#0c4b57ae .cell execution_count=6}\n``` {.python .cell-code}\ndef greet(name=\"there\"):\n    print(f\"Hello, {name}!\")\n\n# Calling the function without passing an argument\ngreet()  # Output: Hello, there!\n\n# Calling the function with an argument\ngreet(\"Alice\")  # Output: Hello, Alice!\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nHello, there!\nHello, Alice!\n```\n:::\n:::\n\n\nIn this example, the `greet(name=\"there\")` function has a default value of `\"there\"` for the `name` argument. If no name is provided, the default message is used.\n\n\n\n### Functions with Keyword Arguments\n\nYou can also call a function using **keyword arguments**. This allows you to specify the arguments by name when calling the function, which can make your code more readable, especially when you have many arguments.\n\n#### Example:\n\n::: {#4516a122 .cell execution_count=7}\n``` {.python .cell-code}\ndef describe_person(name, age, city):\n    print(f\"{name} is {age} years old and lives in {city}.\")\n\n# Calling the function using keyword arguments\ndescribe_person(name=\"Alice\", age=30, city=\"New York\")\n# Output: Alice is 30 years old and lives in New York.\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nAlice is 30 years old and lives in New York.\n```\n:::\n:::\n\n\nIn this case, keyword arguments make it clear which value corresponds to which parameter.\n\n\n\n### Scope of Variables\n\nVariables defined inside a function have **local scope**, meaning they only exist inside that function. Once the function is finished, the variables are destroyed. However, you can define **global variables** outside the function if you need them to be accessible throughout your entire program.\n\n#### Example of Local Scope:\n\n::: {#2d271c28 .cell execution_count=8}\n``` {.python .cell-code}\ndef my_function():\n    x = 10  # This variable only exists inside the function\n    print(x)\n\nmy_function()  # Output: 10\n# print(x)  # This would cause an error because x is not defined outside the function\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n10\n```\n:::\n:::\n\n\n#### Example of Global Scope:\n\n::: {#18d59c00 .cell execution_count=9}\n``` {.python .cell-code}\nx = 5  # Global variable\n\ndef my_function():\n    print(x)  # Accessing the global variable inside the function\n\nmy_function()  # Output: 5\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n5\n```\n:::\n:::\n\n\n### Lambda Functions\n\nIn addition to regular functions, Python supports **lambda functions**, which are small anonymous functions that can be written in a single line. Lambda functions are useful for simple operations and are often used in combination with other functions.\n\n#### Example:\n\n::: {#0fa8d88b .cell execution_count=10}\n``` {.python .cell-code}\n# Regular function to square a number\ndef square(x):\n    return x ** 2\n\n# Lambda function to square a number\nsquare_lambda = lambda x: x ** 2\n\n# Using both functions\nprint(square(5))  # Output: 25\nprint(square_lambda(5))  # Output: 25\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n25\n25\n```\n:::\n:::\n\n\nIn this example, both the regular `square()` function and the lambda function `square_lambda` return the square of a number.\n\n\n\n### Functions and Lists\n\nFunctions can be combined with lists to perform operations on groups of data. For instance, you can use a function to process each item in a list using a loop.\n\n#### Example:\n\n::: {#88f853c3 .cell execution_count=11}\n``` {.python .cell-code}\ndef square(x):\n    return x ** 2\n\nnumbers = [1, 2, 3, 4, 5]\nsquares = []\n\nfor number in numbers:\n    squares.append(square(number))\n\nprint(squares)  # Output: [1, 4, 9, 16, 25]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1, 4, 9, 16, 25]\n```\n:::\n:::\n\n\nIn this example, we define a function `square()` that squares a number. We then use a loop to apply this function to each item in the `numbers` list and store the results in the `squares` list.\n\n\n### Common Practices with Functions\n\nHere are some best practices for working with functions:\n\n1. **Use descriptive names** for your functions and arguments so their purpose is clear.\n   - Good: `def calculate_area(radius):`\n   - Bad: `def ca(r):`\n\n2. **Keep functions short and focused** on a single task. If a function becomes too long, consider breaking it into smaller functions.\n\n3. **Use comments** and **doc strings** to describe what your function does, especially if it’s not immediately obvious.\n\n",
    "supporting": [
      "functions_files"
    ],
    "filters": [],
    "includes": {}
  }
}
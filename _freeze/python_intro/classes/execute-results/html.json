{
  "hash": "7b5b516c580ae63bbb8c3171ba8ae38d",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Classes\"\nformat:\n  html:\n    code-fold: false\njupyter: python3\n---\n\n\n\n\n\nClasses are a fundamental part of object-oriented programming (OOP) in Python. They allow you to create your own data types that combine data (attributes) and functionality (methods) into a single structure. By using classes, you can model real-world entities, promote code reusability, and make your programs more organized and modular.\n\nIn Python, a class serves as a blueprint for creating objects, encapsulating attributes and behaviors that are common to all instances of that class. Let's dive into the concepts of classes, objects, and how to use them in Python.\n\n\n\n### Defining a Class\n\nYou define a class using the `class` keyword followed by the class name. By convention, class names are written in CamelCase.\n\n#### Basic Syntax:\n\n::: {#4ae3cb7d .cell execution_count=1}\n``` {.python .cell-code}\nclass ClassName:\n    # Class attributes and methods go here\n    pass\n```\n:::\n\n\n#### Example:\n\n::: {#a0e5adda .cell execution_count=2}\n``` {.python .cell-code}\nclass Text:\n    pass\n\n# Creating an instance of the Text class\nmy_text = Text()\nprint(my_text)  # Output: <__main__.Text object at 0x...>\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<__main__.Text object at 0x137e24dd0>\n```\n:::\n:::\n\n\nIn this example, we defined a simple class named `Text` and created an instance of it, which is stored in the variable `my_text`.\n\n\n\n### Adding Attributes and Methods\n\nAttributes are variables that belong to the class, while methods are functions defined within the class that can manipulate those attributes or perform actions.\n\nTo define attributes, you typically do this inside a special method called `__init__()`, which initializes the object's attributes when it is created.\n\n#### Example:\n\n::: {#2549971c .cell execution_count=3}\n``` {.python .cell-code}\nclass Text:\n    def __init__(self, content):\n        self.content = content  # Instance attribute\n\n    def word_count(self):  # Method\n        return len(self.content.split())\n\n    def shout(self):  # Another method\n        result = self.content.upper()\n        result = result.replace(\".\", \"!\")\n        return result\n\n# Creating an instance of Text\nmy_text = Text(\"Hello, World! This is a test.\")\nprint(my_text.word_count())  # Output: 6\nprint(my_text.shout())  # Output: HELLO, WORLD! THIS IS A TEST!\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n6\nHELLO, WORLD! THIS IS A TEST!\n```\n:::\n:::\n\n\nIn this example, the `Text` class has an initializer method `__init__()` that takes `content` as a parameter and assigns it to an instance attribute. \nThe `word_count()` method allows you to get the number of words in the text, the `shout()` method transforms all letters to upper case and replaces dots by an exclamation mark.\n\n\n\n### Accessing Attributes and Methods\n\nYou can access attributes and methods of a class instance using the dot `.` notation.\n\n#### Example:\n\n::: {#0d44939a .cell execution_count=4}\n``` {.python .cell-code}\nprint(my_text.content)  # Output: Hello, World! This is a test.\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nHello, World! This is a test.\n```\n:::\n:::\n\n\nIn this example, we access the `content` attribute of `my_text` using dot notation.\n\n\n\n### Class vs. Instance Attributes\n\nAttributes defined inside the `__init__()` method are called **instance attributes** because they belong to a specific instance of the class. \nIn contrast, **class attributes** are shared by all instances of the class and are defined directly within the class body.\n\n#### Example:\n\n::: {#c6f6b307 .cell execution_count=5}\n``` {.python .cell-code}\nclass Text:\n    language = \"English\"  # Class attribute\n\n    def __init__(self, content):\n        self.content = content  # Instance attribute\n\n# Creating instances\ntext1 = Text(\"Hello, World!\")\ntext2 = Text(\"Bonjour, le monde!\")\n\nprint(text1.language)  # Output: English\nprint(text2.language)  # Output: English\n\n# Changing class attribute\nText.language = \"French\"\nprint(text1.language)  # Output: French\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nEnglish\nEnglish\nFrench\n```\n:::\n:::\n\n\nIn this example, we defined a class attribute `language` that is shared by all instances of the `Text` class. Changing the class attribute affects all instances.\n\n\n\n### Inheritance\n\nInheritance allows you to create a new class that inherits attributes and methods from an existing class. This promotes code reuse and makes it easier to create a hierarchy of classes.\n\n#### Example:\n\n::: {#c329d07b .cell execution_count=6}\n``` {.python .cell-code}\nclass Text:\n    def __init__(self, content):\n        self.content = content\n\n    def word_count(self):\n        return len(self.content.split())\n\nclass FormattedText(Text):  # Derived class\n    def __init__(self, content, format_type):\n        super().__init__(content)  # Call the parent class's constructor\n        self.format_type = format_type\n\n    def display(self):\n        return f\"[{self.format_type}] {self.content}\"\n\n# Creating instances\nmy_text = Text(\"Hello, World!\")\nformatted_text = FormattedText(\"Hello, World!\", \"Bold\")\n\nprint(my_text.word_count())  # Output: 2\nprint(formatted_text.display())  # Output: [Bold] Hello, World!\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n2\n[Bold] Hello, World!\n```\n:::\n:::\n\n\nIn this example, we have a base class `Text` and a derived class `FormattedText`. The derived class can extend the functionality of the base class.\n\n",
    "supporting": [
      "classes_files"
    ],
    "filters": [],
    "includes": {}
  }
}